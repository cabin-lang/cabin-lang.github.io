<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Fonts -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap"
		rel="stylesheet">

	<link href="../../shared/shared.css" rel="stylesheet" />
	<link href="./shared_documentation.css" rel="stylesheet" />

	<script src="https://code.jquery.com/jquery-3.7.1.min.js"
		integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
	<script defer src="../../shared/code.ts" type="module"></script>
	<script defer src="./shared_documentation.ts" type="module"></script>

	<title>Document</title>
</head>

<body>
	<section class="sidebar">
		<h1>Index</h1>
		<ul>
			<li>
				<h2>Introduction</h2>
				<ul>
					<li>
						<h3>Purpose & Philosophy</h3>
					</li>
					<li>
						<h3>Installation</h3>
					</li>
					<li>
						<h3>Your First Program</h3>
					</li>
					<li>
						<h3>Compiler Commands</h3>
					</li>
				</ul>
			</li>
			<li>
				<h2>Declarations</h2>
				<ul>
					<li>
						<h3>Names</h3>
					</li>
					<li>
						<h3>Objects</h3>
					</li>
					<li>
						<h3>Functions</h3>
					</li>
					<li>
						<h3>Groups, Eithers, & Unions</h3>
					</li>
				</ul>
			</li>
			<li>
				<h2>Compile-Time by Default</h2>
				<ul>
					<li>
						<h3>What is compile-time?</h3>
					</li>
					<li>
						<h3>Evaluating at compile-time</h3>
					</li>
					<li>
						<h3>Compile-time as the default</h3>
					</li>
					<li>
						<h3>Evaluating at runtime</h3>
					</li>
				</ul>
			</li>
			<li>
				<h2>Groups</h2>
				<ul>
					<li>
						<h3>Declarations & Instantiations</h3>
					</li>
					<li>
						<h3>Nominal Typing</h3>
					</li>
				</ul>
			</li>
			<li>
				<h2><a href="./types.html#types">Types</a></h2>
				<ul>
					<li>
						<h3><a href="./types.html#editable-types">Editable Types</a></h3>
					</li>
					<li>
						<h3><a href="./types.html#type-inference">Type Inference</a></h3>
					</li>
					<li>
						<h3><a href="./types.html#is-types">Is-Types</a></h3>
					</li>
					<li>
						<h3><a href="./types.html#explicit-type-annotations">Explicit Type Annotations</a></h3>
					</li>
					<li>
						<h3><a href="./types.html#convention-notes">Convention Notes</a></h3>
					</li>
				</ul>
			</li>
			<li>
				<h2>Eithers</h2>
				<ul>
					<li>
						<h3>Declarations & Usage</h3>
					</li>
					<li>
						<h3>Property Attachment</h3>
					</li>
				</ul>
			</li>
			<li>
				<h2>Unions</h2>
				<ul>
					<li>
						<h3>Declarations & Usage</h3>
					</li>
					<li>
						<h3>Property Attachment</h3>
					</li>
				</ul>
			</li>
			<li>
				<h2>Reference</h2>
				<ul>
					<li>
						<h3>Keywords</h3>
					</li>
					<li>
						<h3>Formal Grammar</h3>
					</li>
				</ul>
			</li>
		</ul>
	</section>

	<main>
		<h1 id="types">Types</h1>

		<p>
			The term "type" has a very special meaning in Cabin. To understand what a <i>type</i> is, we must first
			understand what a <i>literal</i> is. Simply put, a <i>literal</i> is any construct in Cabin where all
			information about the construct is known. For example, a number is a literal &mdash; It's just a number;
			Everything that can be known about it <i>will</i> be known about it. Conversely, an <code>if</code>
			expression
			is not a literal, because we do not know what object will be returned (the object returned from
			<code>if</code>
			or the object returned from <code>otherwise</code>) so we can't definitively state all of the properties of
			the
			value of this expression.
		</p>

		<p>
			After understanding this, we can talk about <i>types</i>. In Cabin, a <i>type</i> is <strong>any expression
				that
				can be evaluated into a literal at compile-time</strong>. Here are some examples to make this more
			clear:
		</p>

		<pre class="cabin-code">
			let message: Text = "Hello world!";
		</pre>

		<p>
			In this case, the type of the name "message" is <code>Text</code>. <code>Text</code> is an identifier which
			can
			be resolved at compile-time into the group <code>Text</code>, which is a literal! It's a group, so all of
			the
			information about it (its properties) is known at compile-time.
		</p>

		<pre class="cabin-code">
			let get_message_type = function {
				it is Text;
			};

			let message: get_message_type() = "Hello world!";
		</pre>

		<p>
			In this case, the type of the name "message" is the return value of calling <code>get_message_type()</code>.
			<code>get_message_type()</code> can be evaluated fully at compile-time, so it gets called and returns
			<code>Text</code>. In order to use a function call as a type like this, it <i>must</i> be fully evaluable at
			compile-time!
		</p>

		<hr />

		<h2 id="editable-types">Editable</h2>

		<p>
			<code>editable</code> is a modifier that can be applied to types, which means the value of the variable can
			be
			edited. For example:
		</p>

		<pre class="cabin-code">
			let message: editable Text = "Hello world!";
			message = "Goodbye world!"; // This is now valid!
		</pre>

		<hr />

		<h2 id="type-inference">Type Inference</h2>

		<p>
			Cabin supports a feature called <i>type inference.</i> Type inference occurs when you omit a type, and the
			compiler figures out what the type is meant to be. Most of what we've seen so far has used type inference!
			Here's an example:
		</p>

		<pre class="cabin-code">
			let message = "Hello world!"; // This infers the type!
		</pre>

		<p>
			It's important to note that Cabin will <i>never</i> infer a type as <code>editable</code>. All
			<code>editable</code> values must be marked as such explicitly. Also, the type of <code>editable</code>
			names can still be inferred:
		</p>

		<pre class="cabin-code">
			let message: editable = "Hello world!"; // This is valid!
		</pre>

		<hr />

		<h2 id="is-types">Is Types</h2>

		<p>
			It's important to talk about <code>is</code> types. is-types are types which declare that the value must be
			"the thing" as opposed to "an instance of the thing". This sounds confusing, but it's very simple. Here's an
			example:
		</p>

		<pre class="cabin-code">
			let message_1: Text = "Hello world!";
			let message_2: is "Hello world!" = "Hello world!";
		</pre>

		<p>
			These are both valid! This may seem useless, but it may make more sense when we talk about union types:
		</p>

		<pre class="cabin-code">
			let message: editable is "Hello world!" | is "Goodbye world!"= "Hello world!";
			message = "Goodbye world!"; // valid!
			message = "How are you world?"; // Not valid!
		</pre>

		<p>
			It's good to note that if you have a group <code>A</code> and an instance <code>a</code> of that group,
			values
			of type <code>is a</code> are assignable to names of type <code>A</code>. This may sound confusing, but it
			just
			means that if you have a function and name like so:
		</p>

		<pre class="cabin-code">
			let print = function(text: Text) {
				terminal.print(text);
			};

			let message: is "Hello world!" = "Hello world!";
		</pre>

		<p>
			...then message's type is <code>is "Hello world!"</code>, and <code>"Hello world!"</code> is an instance of
			<code>Text</code>, so it's valid to pass <code>message</code> as the parameter to <code>print</code>.
		</p>

		<hr />

		<h2 id="explicit-type-annotations">Explicit Type Annotations</h2>

		<p>
			Now that we've talked about <code>editable</code> types, <code>is</code> types, and type inference, we can
			finally fully explain type inference in Cabin. When you declare a <strong>non-editable</strong> name, Cabin
			will
			infer the type as the <code>is</code> type of the value. For example, if you declare a name as follows:
		</p>

		<pre class="cabin-code">
			let message = "Hello world!";
		</pre>

		<p>
			The inferred type of the name is not actually <code>Text</code>, it's <code>is "Hello world!"</code>. This
			provides as much information as possible at compile-time about the type of the name, and of course, it's
			still assignable to parameters of type <code>Text</code>.
		</p>

		<p>
			As a matter of fact, when you declare a name with a non-editable type in Cabin, you <strong>are not allowed
				to specify an explicit type.</strong> This is because the type is always the most strict and accurate
			possible, which is the <code>is</code> value. In other words, for any declaration:
		</p>

		<pre class="cabin-code">
			let name = value;
		</pre>

		<p>
			...the type of name will always be <code>is value</code>. Thus, specifying a type has no meaning here
			&mdash; a type, by definition in Cabin, means "what kind of values can we assign to this name?" and for a
			non-editable name, it's only the one value.
		</p>

		<hr />

		<h2 id="convention-notes">Convention Notes</h2>

		<p>
			In Cabin, all names are <i>references</i> to a value. This means that editing a name in one place will edit
			its value elsewhere if it wasn't copied. For example:
		</p>

		<pre class="cabin-code">
			let text: editable = "Hello world!";

			let texts: editable = [];
			texts.append(text);

			text.append("!!!");
			texts[1] // "Hello world!!!!"
		</pre>

		<p>
			This also applies to function return values, i.e.,
		</p>

		<pre class="cabin-code">
			let generate = function(): Text {
				let text = "Hello world!";
				texts.append(text);
				it is text;
			};

			let generated_text = generate();
		</pre>

		<p>
			In this case, <code>generated_text</code> is of type <code>Text</code>, not <code>editable Text</code>, and
			it cannot be coerced into being <code>editable</code>. This makes sense, because we don't want to edit this
			value, which <code>texts</code> expects to be unchanging. However, consider a case like this:
		</p>

		<pre class="cabin-code">
			let generate = function(): Text {
				it is "Hello world!";
			};

			let generated_text = generate();
		</pre>

		<p>
			Text literals, in Cabin, is equivalent to a <code>new Text</code> expression, so this returns a new variable
			each time. We arent storing it anywhere, but the caller still can't edit it for the same reasons as before.
			For this reason, it's convention to return an `editable` value whenever you're returning an unstored value:
		</p>

		<pre class="cabin-code">
			let generate = function(): editable Text {
				it is "Hello world!";
			};

			let generated_text = generate();
		</pre>

		<p>
			The Cabin compiler is aware of this convention, and will give you a warning if you do not follow it.
		</p>
	</main>
</body>

</html>